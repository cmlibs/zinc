#! /usr/bin/perl -w

use strict;

my $group;
my $number_of_fields;
my @field_name;
my %field_number_components;
my %field_coordinate_system;
my %field_components_names;
my %field_components_derivatives;
my %field_components_versions;
my %field_components_type_names;
my %field_components_basis;
my %field_components_modification;
my %field_components_mapping;
my %field_components_nodes;
my %field_components_number_of_parameters;
my %field_components_node_indices;
my %field_components_scale_factor_indices;
my $i;
my $j;
my $k;
my $l;
my $values;
my $versions;
my $read_already;
my $node_template_name;
my $element_interpolation_name;
my $scale_factor_list_name;
my %scale_factor_list_lookup;
my $node_list_name;
my $element_template;
my $element_template_name;
my %element_template_lookup;
my $element_nodal_values;
my $element_nodal_values_name;
my %element_nodal_values_lookup;
my $mapping_name;
my $value_type;
my $node_name;
my $dimension;
my $shape;
my $element_name;
my $face_name;
my $node_list_number;
my %scale_factor_list_numbers;
my $number_of_scale_factor_sets;
my $mapping;
my %mapping_lookup;
my $name;
my $new_field;
my $node_index;
my $node_indices;
my $expected_number_of_nodal_values;
my $number_of_nodal_values;
my $scale_factor_indices;
my @list;
my @node_list_indices;
my @derivative_types;
my @scale_factor_list_indices;
my @value_types;
my $derivative;
my $count;
my $derivative_line;
my $basis;
my $index;
my $version;
my $indent;

my $line_name_offset = 100000;
my $face_name_offset = 200000;

my $in_group;
my $in_element_field;
my $node_field_defined;
my $element_field_declared;
my $element_field_defined;

my $end_match = "(Node:|Shape|Group|#Fields|Element)";

$in_group = 0;
$node_field_defined = 0;
$element_field_declared = 0;
$element_field_defined = 0;

$node_template_name = "NodeTemplatdZ";
$element_interpolation_name = "ElementInterpolatiomZ";
$scale_factor_list_name = "ScaleFactorLissZ";
$node_list_name = "ElementNodeLissZ";
$element_template_name = "ElementTemplatdZ";
$element_nodal_values_name = "ElementNodalValuerZ";
$mapping_name = "MappinfZ";

my $time_var = localtime(time());
print <<FIELDML_HEADER;
<fieldml xmlns="http://www.physiome.org.nz/fieldml/0.1#"
         xmlns:fieldml="http://www.physiome.org.nz/fieldml/0.1#">
  <!Generated by ex2fml.pl on $time_var>
FIELDML_HEADER


$read_already = 0;
$_ = <>;
while (defined $_)
  {
	 if (m/Group name\s*:\s*(\w+)/)
	 {
		if ($in_group)
		{
		  if ($group ne $1)
		  {
			 print "</group>\n";
			 $in_group = 0;
		  }
		}
		$group = $1;
	 }

	 elsif (m"#Fields=(\d+)")
	 {
		$number_of_fields = $1;
		for ($i = 0 ; $i < $number_of_fields ; $i++)
		{
		  $_ = <>;
		  if (m"(\d+)\)\s+(\w+),\s+\w+,\s+([^,]+),[^#]*#Components=(\d)+")
		  {
			 if ($1 != $i+1)
			 {
				die ("Unable to read field header, field numbers don't match\n$_");
			 }
			 $name = $2;
			 $field_name[$i] = $2;
			 if (!defined $field_number_components{$name})
			 {
				$new_field = 1;
			 }
			 else
			 {
				$new_field = 0;
			 }
			 define_field_parameter(\$field_number_components{$name}, "number of components",
				 $4, $name, $_);
			 define_field_parameter(\$field_coordinate_system{$name}, "coordinate systems",
				 $3, $name, $_);
			 for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				$_ = <>;
				if (m"([^\.\s]+)\.\s+Value index=\s*\d+,\s+#Derivatives=\s*(\d+)\s*(?:\(([\w/,]*)\))?(?:,\s*#Versions=\s*(\d+))?")
				{
				  define_field_parameter(\$field_components_names{$name}[$j],
					 "component names", $1, $name, $_);
				  $field_components_derivatives{$name}[$j] = $2;
				  if (defined $3)
				  {
					 define_field_parameter(\$field_components_type_names{$name}[$j],
					   "type_names", "value,$3", $name, $_);
				  }
				  else
				  {
					 $field_components_type_names{$name}[$j] = "value";
					 for ($k = 1 ; $k <= $field_components_derivatives{$name}[$j] ; $k++)
					 {
						$field_components_type_names{$name}[$j] .= ",value_$k";
					 }
				  }
				  $field_components_versions{$name}[$j] = $4;
				}
				elsif (m"([^\.\s]+)\.\s+([^,]+),\s+([^,]+),\s+([^\.]+)\.")
				{
				  $element_field_declared = 1;
				  define_field_parameter(\$field_components_names{$name}[$j],
					 "component names", $1, $name, $_);
				  $field_components_basis{$name}[$j] = $2;
				  define_field_parameter(\$field_components_modification{$name}[$j],
					 "component modifications", $3, $name, $_);
				  define_field_parameter(\$field_components_mapping{$name}[$j],
					 "component mappings", $4, $name, $_);
				  $_ = <>;
				  if (m"#Nodes=\s*(\d+)")
				  {
					 $field_components_nodes{$name}[$j] = $1;
					 $node_indices = "";
					 $scale_factor_indices = "";
					 for ($k = 0 ; $k < $field_components_nodes{$name}[$j] ; $k++)
					 {
						$_ = <>;
						if (m"(\d+)\.\s+#Values=\s*(\d+)")
						{
						  $node_index = $1;
						}
						else
 						{
						  die ("Unable to parse field header, could not read node index\n$_");
						}
						$_ = <>;
						chomp;
						if (m"Value indices:\s+(\d+(\s+\d+)*)")
						{
						  $count = scalar (@list = split(/\s+/, $1));
						  @value_types = split(',', $field_components_type_names{$name}[$j]);
						  #Do not use $field_components_versions{$name}[$j] here
						  #as that is just for the last node.  If there are more values
						  #used than value types, assume that is a version.
						  for ($l = 0 ; $l < $count ; $l++)
						  {
							 $version = int(($list[$l]-1) / scalar (@value_types));
							 if ($version)
							 {
								$index = ($list[$l]-1) - $version * scalar (@value_types);
								#Write out the version index starting at 1
								$version++;
								$node_indices .= "$node_index.$version.$value_types[$index] ";
							 }
							 else
							 {
								$node_indices .= "$node_index.$value_types[$l] ";
							 }
						  }
						}
						else
						{
						  die ("Unable to parse field header, could not read value indices\n$_");
						}
						$_ = <>;
						chomp;
						if (m"Scale factor indices:\s+(\d+(\s+\d+)*)")
						{
						  $scale_factor_indices .= "$1 ";
						}
						else
						{
						  die ("Unable to parse field header, could not scale factor indices\n$_");
						}
					 }
					 if ((scalar (@list = split(/\s+/, $node_indices))) !=
						  (scalar (@list = split(/\s+/, $scale_factor_indices))))
					 {
						die ("Unable to parse field header for $name $field_components_names{$name}[$j], number of node_indices does not match number of scale_factor_indices\nnode indices: $node_indices\nscale_factor_indices $scale_factor_indices");
					 }
					 $field_components_number_of_parameters{$name}[$j] = scalar @list;
					 $field_components_node_indices{$name}[$j] = $node_indices;
					 $field_components_scale_factor_indices{$name}[$j] = $scale_factor_indices;
				  }
				  else
				  {
					 die ("Unable to read field header, number node line didn't parse\n$_");
				  }
				}
				else
				{
				  die ("Unable to read field header, component line didn't parse\n$_");
				}
			 }
		  }
		  else
		  {
			 die ("Unable to read field header, field line didn't parse\n$_");
		  }

		  if ($new_field)
		  {
			 $name = $field_name[$i];
			 print <<FIELD_HEADER_1;
	<field name="$field_name[$i]"
		    value_type="real"
		    coordinate_system="$field_coordinate_system{$name}">
FIELD_HEADER_1

			 for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				print <<FIELD_HEADER_2
		<component name="$field_components_names{$name}[$j]"/>
FIELD_HEADER_2
			 }
			 print <<FIELD_HEADER_3;
	</field>

FIELD_HEADER_3
		  }
		}

		$node_field_defined = 0;
		$element_field_defined = 0;

	 }

#Nodes
	 elsif (m/Node:\s*(\d+)/)
	 {
		$node_name = $1;
		$_ = <>;		
		$values = "";
		while ((defined $_) && (! /$end_match/))
		{
		  $values .= $_;
		  $_ = <>;
		}
		$read_already = 1;

		if (! $in_group)
		{
		  print <<GROUP_HEADER;
	<group name="$group">

GROUP_HEADER
        $in_group = 1;
		}

#Write the node field if the field is new or different
		if (! $node_field_defined)
		{
		  $node_template_name++;
		  $expected_number_of_nodal_values = 0;
		  print <<NODE_VALUES_FIELD_1A;
	  <labels_template name="$node_template_name">
NODE_VALUES_FIELD_1A
        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
			 print <<NODE_VALUES_FIELD_1B;
		 <field_ref ref="$name">
NODE_VALUES_FIELD_1B

          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				print <<NODE_VALUES_FIELD_2;
			<component_ref ref="$field_components_names{$name}[$j]">
NODE_VALUES_FIELD_2

				if (defined $field_components_versions{$name}[$j])
				  {
					 $versions = $field_components_versions{$name}[$j];
				  }
				else
				  {
					 $versions = 1;
				  }
				for ($l = 1 ; $l <= $versions ; $l++)
				{
				  $indent = "";
				  if ($versions > 1)
				  {
					 print <<NODE_VALUES_FIELD_3A;
           <label name="version_$l">
NODE_VALUES_FIELD_3A
                $indent = "  ";
				  }
				  for $value_type (split(',', $field_components_type_names{$name}[$j]))
				  {
					 print <<NODE_VALUES_FIELD_3;
$indent           <label name="$value_type"/>
NODE_VALUES_FIELD_3
					 $expected_number_of_nodal_values++;
				  }
				  if ($versions > 1)
				  {
					 print <<NODE_VALUES_FIELD_3B;
			  </label>
NODE_VALUES_FIELD_3B
				  }
				}
				print <<NODE_VALUES_FIELD_5;
			</component_ref>
NODE_VALUES_FIELD_5
			 }
		  print <<NODE_VALUES_FIELD_6;
	    </field_ref>
NODE_VALUES_FIELD_6
		  }
		  print <<NODE_VALUES_FIELD_7;
	  </labels_template>

NODE_VALUES_FIELD_7
         $node_field_defined = 1;
		}
		
		#Strip leading and trailing whitespace
		$values =~ s/^\s+//;
		$values =~ s/\s+$//;
		#Split into the number of values.
		$number_of_nodal_values = scalar (@list = split(/\s+/, $values));
		if ($expected_number_of_nodal_values != $number_of_nodal_values)
		{
		  for $i (@list)
		  {
			 print (STDERR " Item:$i\n");
		  }
		  die ("Number of values ($number_of_nodal_values) in node $node_name does not match the expected number ($expected_number_of_nodal_values) from the header");
		}

#Write the actual node		
		print <<NODE_1;
	  <node name="$node_name">
		 <assign_labels template_name="$node_template_name">
$values
		 </assign_labels>
	  </node>

NODE_1
	 }

#Elements
	 elsif (m/Shape.\s+Dimension=(\d+)(,\s([;\w\(\)\*]*))?/)
	 {
		$dimension = $1;
		if (defined $3)
		{
		  $shape = $3;
		}
		else
		{
		  if ($dimension == 1)
		  {
			 $shape = "line";
		  }
		  elsif ($dimension == 2)
		  {
			 $shape = "line*line";
		  }
		  elsif ($dimension == 3)
		  {
			 $shape = "line*line*line";
		  }
		}
	 }

	 elsif (m"#Nodes=\s*(\d+)")
	 {
		$node_list_number = $1;
		$node_list_name++;
      %mapping_lookup = ();
	 }

	 elsif (m"#Scale factor sets=\s*(\d+)")
	 {
		$scale_factor_list_name++;
		if (defined $1)
		{
		  $number_of_scale_factor_sets = $1;
		}
		else
		{
		  die ("Could not parse number of scale factors\n$_");
		}
		for ($i = 0 ; $i < $number_of_scale_factor_sets ; $i++)
		{
		  $_ = <>;
		  if (m"([\w\*\.\(\)\;]+),\s*#Scale factors=\s*(\d+)")
			 {
				$scale_factor_list_lookup{$1} = $scale_factor_list_name;
				$scale_factor_list_numbers{$1} = $2;
			 }
		  else
			 {
				die ("Could not parse number of scale factors\n$_");
			 }
		}
		%mapping_lookup = ();
	 }

	 elsif (m/Element:\s+(\d+)\s+(\d+)\s+(\d+)/)
	 {
		if ($element_field_declared && ! $element_field_defined)
		{
#Pre define any new mapping schemes we haven't seen before
        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				$basis = $field_components_basis{$name}[$j];
				if (! $mapping_lookup{$basis})
				{
				  $mapping_name++;
				  $mapping_lookup{$basis} = $mapping_name;
				  $element_nodal_values_name++;
				  $element_nodal_values_lookup{$basis} = $element_nodal_values_name;
				  if (! defined $scale_factor_list_lookup{$basis})
				  {
					 die ("No scale factor set found for basis $basis\n$_");
				  }
#           What if we don't want to start with the first scale factor
#				@scale_factor_list_indices = split(/\s+/, $field_components_scale_factor_indices{$name}[$j]);
 				  print <<MAPPING_1;
		<mapping name="$mapping_name"
					      basis="$basis"
					      modification="$field_components_modification{$name}[$j]">
        <coefficients>
           <product>
              <element_lookup>
                <field_lookup>
                  <component_lookup>
                    <label name="$element_nodal_values_name"/>
                  </component_lookup>
                </field_lookup>
              </element_lookup>
              <element_lookup>
                <label name="$scale_factor_list_lookup{$basis}"/> #Need offset/split lists
              </element_lookup>
           </product>
        </coefficients>
		</mapping>

MAPPING_1
				}
			 }
		  }

        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				@node_list_indices = split(/\s+/, $field_components_node_indices{$name}[$j]);
				#Split and rejoin the values so that they have identical formatting
				$index = "@node_list_indices";
				if (! defined $element_template_lookup{$index})
				{
				  $element_template_name++;
				  $element_template_lookup{$index} = $element_template_name;
 				  print <<ELEMENT_TEMPLATE_1;
		<labels_template name="$element_template_name">
ELEMENT_TEMPLATE_1

              for ($k = 0 ; $k < $field_components_number_of_parameters{$name}[$j] ; $k++)
              {
					 if ($node_list_indices[$k] =~ m/([^.\s]+)\.([^.\s]+)\.([^.\s]+)/)
					 {
						$node_index = $1;
						$version = "version_$2";
						$value_type = $3;
				    print <<ELEMENT_TEMPLATE_2A;
        <node_lookup>
          <node>
            <element_lookup>
              <label indices="$node_list_name">
                <label indices="$node_index"/>
              </label>
            </element_lookup>
          </node>
          <field_lookup>
            <component_lookup>
              <label indices="$version">
                <label indices="$value_type">
              </label>
            </component_lookup>
          </field_lookup>
        </node_lookup>
ELEMENT_TEMPLATE_2A
					 }
					 elsif ($node_list_indices[$k] =~ m/([^.\s]+)\.([^.\s]+)/)
					 {
						$node_index = $1;
						$value_type = $2;
				    print <<ELEMENT_TEMPLATE_2B;
        <node_lookup>
          <node>
            <element_lookup>
              <label indices="$node_list_name">
                <label indices="$node_index"/>
              </label>
            </element_lookup>
          </node>
          <field_lookup>
            <component_lookup>
              <label indices="$value_type"/>
            </component_lookup>
          </field_lookup>
        </node_lookup>
ELEMENT_TEMPLATE_2B
                }
                else
                {
                  die ("Unable to parse node_list_indices $node_list_indices[$k]");
                }
              }
				 print <<ELEMENT_TEMPLATE_3;
		</labels_template>

ELEMENT_TEMPLATE_3

             }
			  }
		  }

#Now use these in the element interpolation
		  $element_interpolation_name++;
		  print <<ELEMENT_FIELD_1;
		<element_interpolation name="$element_interpolation_name">
ELEMENT_FIELD_1

        for ($i = 0 ; $i < $number_of_fields ; $i++)
		  {
			 $name = $field_name[$i];
		  print <<ELEMENT_FIELD_2;
		  <field_ref ref="$field_name[$i]">
ELEMENT_FIELD_2
          for ($j = 0 ; $j < $field_number_components{$name} ; $j++)
			 {
				@node_list_indices = split(/\s+/, $field_components_node_indices{$name}[$j]);
				#Split and rejoin the values so that they have identical formatting
				$index = "@node_list_indices";
				$element_template = $element_template_lookup{$index};
				$basis = $field_components_basis{$name}[$j];
				$element_nodal_values = $element_nodal_values_lookup{$basis};
				print <<ELEMENT_FIELD_3;
			 <component_ref ref="$field_components_names{$name}[$j]">
				<mapping_ref ref="$mapping_lookup{$basis}"/>
            <label name="$element_nodal_values">
              <reference_labels template="$element_template"/>
            </label>
			 </component_ref>
ELEMENT_FIELD_3
			 }
		  print <<ELEMENT_FIELD_5;
		  </field_ref>
ELEMENT_FIELD_5
		  }
		  print <<ELEMENT_FIELD_6;
		</element_interpolation>

ELEMENT_FIELD_6

		  $element_field_defined = 1;
		}

		if ($dimension == 1)
		{
		  $element_name = $3 + $line_name_offset;
		}
		elsif ($dimension == 2)
		{
		  $element_name = $2 + $face_name_offset;
		}
		elsif ($dimension == 3)
		{
		  $element_name = $1;
		}
		else
		{
		  die ("Unable to read element, dimension is $dimension");
		}
	
 		print <<ELEMENT_HEADER;
		<element	name="$element_name"
               shape="$shape">
ELEMENT_HEADER

      $in_element_field = 0;
		$_ = <>;
		while ((defined $_) && (! m/$end_match/))
		{
		  if (m/Faces:/)
		  {
			 print <<ELEMENT_FACES_1;
		  <faces>
ELEMENT_FACES_1
			 $_ = <>;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				if (m/(\d+)\s+(\d+)\s+(\d+)/)
				{
				  if ($dimension == 3)
				  {
					 $face_name = $2 + $face_name_offset;
				  }
				  elsif ($dimension == 2)
				  {
					 $face_name = $3 + $line_name_offset;
				  }
				  else
				  {
					 die ("Unable to read faces, dimension is $dimension");
				  }
				  print " $face_name";
				}
				else
				{
				  die ("Unable to read face, line didn't parse\n$_");
				}
				$_ = <>;
			 }

			 print <<ELEMENT_FACES_3;

		  </faces>
ELEMENT_FACES_3
		  }
 		  elsif (m/Nodes:/)
		  {
			 print <<ELEMENT_NODES_1;
		  <element_interpolation_ref ref="$element_interpolation_name"/>
		  <label name="$node_list_name">
ELEMENT_NODES_1
          $_ = <>;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				print $_;
				$_ = <>;
			 }

			 print <<ELEMENT_NODES_3;
		  </label>
ELEMENT_NODES_3
		  }
 		  elsif (m/Scale factors:/)
		  {
			 print <<ELEMENT_SCALE_2;
		  <label name="$scale_factor_list_name">
ELEMENT_SCALE_2

          $_ = <>;
			 while ((defined $_) && (! m/(Scale|Nodes)/) &&
				 (! m/$end_match/))
			 {
				print $_;
				$_ = <>;
			 }

			 print <<ELEMENT_SCALE_3;
		  </label>
ELEMENT_SCALE_3
		  }
		  else
		  {
			 $_ = <>;
		  }
		}

 		print <<ELEMENT_END;
		</element>

ELEMENT_END
		$read_already = 1;
	 }

	 if ($read_already)
		{
		  $read_already = 0;
		}
	 else
		{
		  $_ = <>;
		}
  }

if ($in_group)
  {
	 print <<END_GROUP;
	</group>
END_GROUP
  }

print "</fieldml>\n";


sub define_field_parameter
{
  my $parameter_ref = shift;
  my $parameter_name = shift;
  my $new_value = shift;
  my $name = shift;
  my $line = shift;

  if (defined $$parameter_ref)
  {
	 if ($$parameter_ref ne $new_value)
	 {
		die ("Redefinition of field $name is inconsistent, $parameter_name don't match\n$line");
	 }
  }
  else
  {
	 $$parameter_ref = $new_value;
  }
}
